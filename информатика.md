# [Оглавление (навигация) ](#оглавление-навигация)
<img src="https://sun9-20.userapi.com/impg/R59vKZefW7pYprW6rik0fiv1Wealb_8Xf8EhsQ/Axwig6SHHiM.jpg?size=1080x798&quality=95&sign=08cc1541f08f885da122af7d38a65b49&type=album" width="1500" height="300" />

# Основы информатики, определение и содержание понятия информации.

## Теория информации

Тео́рия информа́ции, раздел математики, исследующий процессы хранения, преобразования и передачи информации. Теория информации – часть кибернетики. В основе теории информации лежит определённый способ измерения количества информации, содержащейся в каких-либо данных (сообщениях)
## Формула Хартли

Для того чтобы измерить количество информации в сообщении, надо закодировать сообщение в виде последовательности нулей и единиц **наиболее рациональным способом,** позволяющим получить **самую короткую последовательность**. Длина полученной последовательности нулей и единиц и является **мерой количества информации** в битах.

Пусть у нас есть $N$ возможных равновероятных вариантов исходов некоторого события. Какое количество информации нам нужно получить, чтобы оставить только один вариант?

Ответ на этот вопрос даёт **формула Хартли**: $i=log_a N$ , где $N$ – это количество исходов, а $i$ – количество информации, которое нужно получить для однозначного выбора $1$ исхода. Основание логарифма обозначает единицу измерения количества информации. То есть если мы будем измерять количество информации в битах, то логарифм нужно брать по основанию $2$, а если основной единицей измерения станет трит, то, соответственно, логарифм берётся по основанию $3$.

**Формула Хартли** определяет количество необходимой информации для выявления определенного элемента множества при условии, что все элементы **равновероятны**.

## Общая энтропия по Шеннону

Вероятностный подход Шеннона обобщает меру количества информации по Хартли на случай, когда не все элементы множества являются равнозначными, а также с учётом влияния шума в канале связи.

**Энтропия по Шеннону**  - мера неопределённости (непредсказуемости, неожиданности) появления символа. Мера равномерности распределения случайной величины. Среднее значение количества информации в сообщении. Количество информации, приходящейся на одно элементарное сообщение источника.

**Энтропия Шеннона** оценивает среднее количество информации (математическое ожидание), которое содержится в значениях случайной величины. 


**Формула энтропии**: $H=-\sum _{i=1}^{N}p_{i}\log p_{i}$


Клод Шеннон заметил, что **информационная энтропия** подчиняется следующим закономерностям:

А) Энтропия события равна 0, если его вероятность равна 1 (100%);
Б) Энтропия двух независимых событий равна сумме энтропий этих событий;
В) Энтропия максимальна, если все события равновероятны.

Получается, чем сложнее предсказать исход события, тем больше информации оно несёт. Если событие редкое и непредсказуемое, мы называем его новостью и наделяем информационной ценностью. Если же оно повторяется часто и о нём постоянно рассказывают, его информационная ценность теряется.

## Категории и свойства информации

### Категории:

#### По форме представления

- Текстовая: информация, представленная в виде символов, букв и цифр
- Числовая: данные, выраженные с помощью цифр
- Графическая: рисунки, фотографии, схемы, чертежи
- Звуковая: информация, воспринимаемая органами слуха
- Видеоинформация: динамические изображения


#### По способу восприятия

- Визуальная: воспринимаемая органами зрения
- Аудиальная: воспринимаемая органами слуха
- Тактильная: воспринимаемая через осязание
- Обонятельная: воспринимаемая через запах
- Вкусовая: воспринимаемая вкусовыми рецепторами


#### По назначению

- Массовая: предназначенная для широкой аудитории
- Специальная: предназначенная для узкого круга специалистов


#### По содержанию

- Фактографическая: описание фактов и событий
- Аналитическая: анализ и сопоставление фактов
- Справочная: статичное описание объектов
- Методическая: описание способов и методов


#### По полезности

- Полезная: необходимая для принятия решений
- Бесполезная: не являющаяся необходимой


#### По степени обобщения

- Обобщенная: сводная информация
- Детальная: подробная, не подвергшаяся обобщению


### Свойства
#### Объективность

«На улице холодно», — сказала мама. «На улице +3», — сказал папа. Информация папы **объективна**: температура +3 одинакова для всех, вне зависимости от того, кто говорит, слушает и где происходит ситуация. Мамина оценка «холодно» субъективна: кому-то может быть холодно при температуре +10 или –30.

#### Достоверность

«У меня сегодня двоек нет!» — радостно сообщает ученик. Но мама на всякий случай звонит классной руководительнице, чтобы получить **достоверную** информацию из надёжного источника.
#### Актуальность

На железнодорожной станции висит табличка с расписанием электричек. Она не новая — потемнела, буквы расплылись. **Актуальную** информацию о расписании стоит поискать в интернете и обратить при этом внимание на время последнего обновления страницы.

#### Ясность

Внук рассказывает бабушке про проблемы в группе его класса во «ВКонтакте»: «Столько спама, хайпа, приходится модерировать, троллей банить». Бабушка кивает, хотя не понимает ни слова: информация для неё не обладает свойством **ясности**.

#### Полнота

«Задуманное натуральное число больше трёх и меньше шести» — информации недостаточно, чтобы отгадать число. Но если добавить в условие слово «чётное», информация станет полной. **Полнота** — достаточность информации для принятия решения.

#### Ценность

Катя получила во «ВКонтакте» два сообщения. В первом говорилось, что завтра будут нужны лыжи для урока физкультуры. Во втором девочка прочитала, что какая-то неизвестная ей певица в восьмой раз вышла замуж. Первое сообщение ценное: оно повлияет на принимаемые Катей решения. Информацию же о восьмом браке певицы девочка сразу отфильтрует — на жизни Кати этот факт никак не отразится.

## Формы представления информации в профессиональной деятельности
- **Текстовая информация**: Это наиболее распространенная форма, которая включает в себя документы, отчеты, статьи и другие письменные материалы. Текстовая информация позволяет детально излагать мысли и идеи, а также служит основой для официальных записей.
    
- **Графическая информация**: Включает в себя диаграммы, графики, инфографику и изображения. Графические элементы помогают визуализировать данные и делают информацию более доступной для восприятия, особенно в сложных отчетах или презентациях.
    
- **Аудиальная информация**: Представляется в виде звуковых записей, подкастов или аудиопрезентаций. Этот формат полезен для обучения и передачи информации, когда визуальные элементы не являются приоритетом.
    
- **Визуальная информация**: Включает видео и анимации, которые могут быть использованы для демонстрации процессов или представления сложных концепций в более понятной форме. Визуальные материалы часто используются в обучении и маркетинге.
    
- **Интерактивные формы**: Это могут быть презентации с элементами взаимодействия, такие как опросы или обсуждения, которые вовлекают аудиторию и способствуют лучшему усвоению информации.

## Базовые информационные технологии

**Базовые информационные технологии**  представляют собой совокупность методов, процессов и инструментов, используемых для обработки, хранения и передачи информации. Они играют важную роль в современном обществе, обеспечивая эффективное управление данными и поддерживая различные бизнес-процессы.

#### Основные компоненты базовых информационных технологий

- **Аппаратное обеспечение**: Включает в себя физические устройства, такие как компьютеры, серверы, сетевое оборудование и устройства хранения данных. Эти компоненты обеспечивают необходимую инфраструктуру для работы программного обеспечения и обработки информации.
    
- **Программное обеспечение**: Состоит из системного и прикладного ПО. Системное ПО управляет аппаратными ресурсами, а прикладное ПО выполняет конкретные задачи, такие как обработка текстов, работа с таблицами и управление базами данных.
    
- **Сетевые технологии**: Обеспечивают связь между устройствами и позволяют обмениваться данными. Это включает в себя как локальные сети (LAN), так и глобальные сети (WAN), такие как Интернет.
    
- **Базы данных**: Системы, предназначенные для хранения и управления данными. Они позволяют эффективно организовывать, извлекать и обновлять информацию, что критически важно для бизнеса и научных исследований.
## Модифицированные коды

**Модифицированные коды** представляют собой специальные системы кодирования, используемые в вычислительной технике для улучшения обработки чисел и выявления ошибок при арифметических операциях. Они играют важную роль в обеспечении точности и надежности вычислений в электронных вычислительных машинах (ЭВМ).

### Типы модифицированных кодов

- **Модифицированный обратный код**: Этот код используется для представления отрицательных чисел. Он формируется путем инверсии всех битов числа и добавления единицы к младшему разряду. Модифицированный обратный код позволяет выполнять арифметические операции, такие как сложение и вычитание, через операцию сложения, что упрощает конструкцию арифметического устройства.
    
- **Модифицированный дополнительный код**: Подобно модифицированному обратному коду, дополнительный код также используется для представления отрицательных чисел, но с добавлением единицы к инвертированному коду. Это позволяет избежать проблем с переполнением разрядной сетки, так как модифицированные коды могут использовать два разряда для знака числа, что позволяет более точно определять его знак и выявлять ошибки.
    

### Преимущества модифицированных кодов

- **Обнаружение переполнения**: Модифицированные коды позволяют легко выявлять переполнение разрядной сетки. Если в знаковых разрядах появляется комбинация "01" или "10", это сигнализирует о том, что произошло переполнение, и результат арифметической операции может быть неверным.
    
- **Упрощение арифметических операций**: Использование модифицированных кодов позволяет свести сложение и вычитание к одной операции — сложению. Это упрощает конструкцию арифметических блоков в ЭВМ и повышает их производительность.
    
- **Улучшение точности**: Модифицированные коды обеспечивают более точное представление чисел, что критически важно для вычислений, требующих высокой степени точности, таких как научные расчеты и финансовые приложения.
    

### Применение модифицированных кодов

Модифицированные коды широко используются в различных областях, включая:

- **Компьютерные архитектуры**: В современных процессорах модифицированные коды применяются для оптимизации арифметических операций и повышения производительности вычислений.
    
- **Системы обработки данных**: В системах, где требуется высокая надежность и точность, модифицированные коды помогают минимизировать ошибки и обеспечивать корректность вычислений.



# Объем информации и системы счисления.
## Представление чисел в позиционных системах счисления.

**Позиционная система счисления** — система счисления, в которой значение цифры в записи числа зависит от её позиции в числе. В такой системе любое число может быть представлено в виде суммы степеней основания системы счисления

Запись 12 обозначает число двенадцать, а 21 — двадцать один.

Представление числа в позиционной системе счисления имеет две формы:

1. Развернутая форма записи:
   $$a = a_n \cdot P^n + a_{n-1} \cdot P^{n-1} + ... + a_2 \cdot P^2 + a_1 \cdot P + a_0 + a_{-1} \cdot P^{-1} + ... + a_{-m} \cdot P^{-m}$$
   где P - основание системы счисления, a_i - цифры числа a.

2. Свернутая форма записи:
   $$a = a_n...a_1a_0a_{-1}...a_{-m}$$
   где цифры перечисляются последовательно, начиная со старшего разряда, а целая часть отделяется от дробной запятой.

Основание системы счисления (P) - это количество цифр, используемых в данной системе. Например, в десятичной системе основание равно 10, а в двоичной - 2.

Важно отметить, что в любой позиционной системе счисления основание системы всегда записывается как 10. Например, в двоичной системе запись 10 означает число 2 в десятичной системе.
## Перевод из любой системы счисления в десятичную и обратно.
### Перевод из любой системы в десятичную

Для перевода числа из любой системы счисления в десятичную используется следующий алгоритм:

1. Пронумеруйте разряды числа, начиная с нуля справа налево для целой части и слева направо для дробной части.
2. Умножьте каждую цифру на основание системы в степени, равной номеру разряда.
3. Сложите полученные произведения.

Например, для числа 1001101.1101 в двоичной системе:

$$1\cdot2^6 + 0\cdot2^5 + 0\cdot2^4 + 1\cdot2^3 + 1\cdot2^2 + 0\cdot2^1 + 1\cdot2^0 + 1\cdot2^{-1} + 1\cdot2^{-2} + 0\cdot2^{-3} + 1\cdot2^{-4}$$

$$= 64 + 0 + 0 + 8 + 4 + 0 + 1 + 0.5 + 0.25 + 0 + 0.0625 = 77.8125_{10}$$

### Перевод из десятичной в другую систему

1. Последовательно делите число на основание новой системы.
2. Записывайте остатки от деления.
3. Полученные остатки в обратном порядке дадут число в новой системе.

Пример перевода 375₁₀ в двоичную систему:

375 ÷ 2 = 187 (остаток 1)
187 ÷ 2 = 93 (остаток 1)
93 ÷ 2 = 46 (остаток 1)
46 ÷ 2 = 23 (остаток 0)
23 ÷ 2 = 11 (остаток 1)
11 ÷ 2 = 5 (остаток 1)
5 ÷ 2 = 2 (остаток 1)
2 ÷ 2 = 1 (остаток 0)
1 ÷ 2 = 0 (остаток 1)

Результат: 375₁₀ = 101110111₂
## Переходы между системами счисления с основаниями степени двойки
#### Перевод из систем с большим основанием в двоичную

При переводе из восьмеричной или шестнадцатеричной системы в двоичную каждую цифру исходного числа заменяют на её двоичное представление:

1. Для восьмеричной системы каждую цифру заменяют на 3 двоичные цифры.
2. Для шестнадцатеричной системы каждую цифру заменяют на 4 двоичные цифры.

Например:
- 52₈ = 101 010₂
- A3₁₆ = 1010 0011₂

#### Перевод из двоичной в системы с большим основанием

При переводе из двоичной системы в восьмеричную или шестнадцатеричную двоичное число разбивают на группы по 3 или 4 цифры соответственно, начиная справа:

1. Для перевода в восьмеричную систему группируют по 3 бита.
2. Для перевода в шестнадцатеричную систему группируют по 4 бита.

Затем каждую группу заменяют соответствующей цифрой новой системы счисления.

Например:
- 1011010₂ = 132₈ (группы: 001 011 010)
- 1011010₂ = 5A₁₆ (группы: 0101 1010)


# Представление чисел в ЭВМ кодирование
## Представление положительных целых чисел.

Представление положительных целых чисел в ЭВМ осуществляется в двоичной системе счисления. Для хранения чисел выделяется фиксированное количество байтов (обычно 1, 2, 4 или 8).

Положительные целые числа в компьютере могут быть представлены двумя способами:

1. Целые числа без знака (unsigned integer):
   - Используют все биты для представления значения числа.
   - Диапазон значений: от 0 до 2^n - 1, где n - количество бит.
   - Например, для 8-битного представления диапазон составляет 0-255, для 16-битного - 0-65535.

2. Целые числа со знаком (signed integer):
   - Используют прямой, обратный или дополнительный код.
   - Старший (левый) бит отводится под знак числа, где 0 означает положительное число.
   - Оставшиеся биты содержат двоичную запись числа.

Для положительных чисел представление в прямом, обратном и дополнительном кодах идентично. Например, число 12 в 8-битном формате будет представлено как 00001100.

При вводе числа в компьютер оно автоматически преобразуется из привычной десятичной системы в двоичный код. Это позволяет эффективно выполнять арифметические операции, используя известные алгоритмы поразрядной обработки для битовых наборов.

## Прямой, обратный и дополнительный код для отрицательных чисел.
### Прямой код

Прямой код - самый простой способ представления отрицательных чисел:

- Старший бит используется для обозначения знака (0 для положительных, 1 для отрицательных чисел).
- Остальные биты содержат абсолютное значение числа в двоичной форме.
- Существует два представления нуля: +0 (0000...0) и -0 (1000...0).

### Обратный код

Обратный код используется для упрощения операций вычитания:

- Для положительных чисел совпадает с прямым кодом.
- Для отрицательных чисел все биты, кроме знакового, инвертируются (0 меняется на 1, 1 на 0).
- Также имеет два представления нуля, что может приводить к ошибкам в арифметических операциях.

### Дополнительный код

Дополнительный код - наиболее распространенный метод представления отрицательных чисел в современных компьютерах:

- Для положительных чисел совпадает с прямым кодом.
- Для отрицательных чисел формируется путем инвертирования всех битов числа и добавления 1 к младшему разряду.
- Имеет только одно представление нуля, что устраняет проблему двух нулей, присущую обратному коду.

Преимущества дополнительного кода:

1. Упрощает выполнение арифметических операций, позволяя использовать одинаковые алгоритмы для положительных и отрицательных чисел.
2. Обеспечивает более эффективное использование диапазона чисел. Например, для 8-битного представления диапазон составляет от -128 до 127.
### Пример
#### Прямой код

Прямой код используется для представления как положительных, так и отрицательных чисел.

- +5: 00000101
- -5: 10000101

#### Обратный код

Обратный код для положительных чисел совпадает с прямым, а для отрицательных инвертируются все биты, кроме знакового.

- +5: 00000101
- -5: 11111010

#### Дополнительный код

Дополнительный код для положительных чисел совпадает с прямым, а для отрицательных формируется путем инвертирования всех битов и добавления 1.

- +5: 00000101
- -5: 11111011

Пример сложения в дополнительном коде:

  00000101 (+5)
  +
  11111011 (-5)
  ----------------
  00000000 (0)

Преимущество дополнительного кода заключается в том, что он позволяет выполнять арифметические операции с положительными и отрицательными числами одинаково, без необходимости отдельной обработки знака.

## Сложение и вычитание целых чисел.
### Сложение целых чисел

Сложение целых чисел в ЭВМ выполняется по следующим шагам:

1. **Сложение чисел в прямом коде**: Если оба числа положительные, просто складываются их значения. Если одно из чисел отрицательное, используется дополнительный код.
    
2. **Сложение чисел в дополнительном коде**:
    
    - Если оба числа положительные, результат также будет положительным.
    - Если одно число отрицательное, то его дополнительный код складывается с положительным числом. Например:
        - Прямой код числа 5: 000001010 000010100000101
        - Дополнительный код числа -7: 111110011 111100111111001
        - Сложение:
            
            0 0000101
          + 1 1111001
            -------------
            1 1111110
            
    - Результат в дополнительном коде может быть преобразован обратно в прямой код для интерпретации.
3. **Обработка переполнения**: Если старший бит (знаковый) результата отличается от знаков входных чисел, это указывает на переполнение.
    

### Вычитание целых чисел

Вычитание в ЭВМ обычно выполняется с использованием сложения, что упрощает процесс. Для этого используется дополнительный код:

1. **Преобразование вычитания в сложение**: Чтобы вычесть число, необходимо прибавить его дополнительный код. Например, для вычитания числа BBB из числа AAA (то есть A−BA - BA−B):
    
    - Вычисляется дополнительный код числа BBB.
    - Сложите число AAA с дополнительным кодом BBB.
2. **Пример**: Вычтем 5 из 7:
    
    - Прямой код числа 7: 000001110 000011100000111
    - Прямой код числа 5: 000001010 000010100000101
    - Дополнительный код числа 5:
        - Инверсия: 111110101 111101011111010
        - Прибавление 1: 111110111 111101111111011
    - Сложение:
        
          00000111
          +
          11111011
          -------------
          00001100
        
    - Результат 000011000 000110000001100 соответствует числу 2.

## Вещественные числа и их представление

### Форматы представления

В ЭВМ вещественные числа могут быть представлены в нескольких форматах, наиболее распространенными из которых являются:

- **Формат с плавающей запятой**: Этот формат позволяет представлять числа в виде мантиссы и порядка (показателя степени). Например, число может быть записано как $m \times 10^n$ , где $m$ — мантисса, а $n$ — порядок. В двоичной системе это представление выглядит как $m \times 2^n$.

- **Формат с фиксированной запятой**: В этом формате число представляется как целое число с фиксированным количеством разрядов после запятой. Этот метод менее гибок, так как диапазон представимых значений ограничен.

### Стандарт IEEE 754

Наиболее распространенный стандарт для представления вещественных чисел в ЭВМ — это стандарт IEEE 754. Он определяет несколько форматов, включая:

- **Одинарная точность (32 бита)**: Состоит из 1 бита знака, 8 битов для порядка и 23 битов для мантиссы.
  
- **Двойная точность (64 бита)**: Состоит из 1 бита знака, 11 битов для порядка и 52 битов для мантиссы.

- **Расширенная точность**: Использует больше бит для представления, что позволяет достичь большей точности и диапазона.

### Структура числа с плавающей запятой

Число с плавающей запятой в формате IEEE 754 состоит из следующих частей:

- **Знак мантиссы**: Указывает, является ли число положительным или отрицательным.
  
- **Мантисса**: Представляет значение числа без учета порядка. В нормализованной форме мантисса находится в диапазоне от 1 до 2 (для двоичных чисел).

- **Знак порядка**: Указывает на знак порядка.

- **Порядок**: Определяет степень, на которую мантисса умножается.

### Преимущества формата с плавающей запятой

Формат с плавающей запятой позволяет представлять широкий диапазон значений с фиксированной относительной точностью. Это особенно полезно для научных расчетов, где могут встречаться как очень большие, так и очень маленькие числа. Например, в формате с плавающей запятой можно записать числа от  $1.4 \times 10^{-45}$  до $3.4 \times 10^{38}$ в одинарной точности.

### Арифметические операции с вещественными числами

Арифметические операции с вещественными числами, такие как сложение, вычитание, умножение и деление, требуют особого подхода:

- **Сложение и вычитание**: Перед выполнением операции необходимо уравнять порядки слагаемых. Это означает, что меньший порядок увеличивается до большего, после чего складываются мантиссы.

- **Умножение**: При умножении мантиссы перемножаются, а порядки складываются.

- **Деление**: При делении мантисса делимого делится на мантиссу делителя, а порядок делимого уменьшается на порядок делителя.
## Модифицированные коды.
ссылка на первую тему
## Представление чисел с фиксированной точкой.

#### Формат хранения

В формате с фиксированной точкой число представляется как целое число, где определенное количество битов отводится под целую часть, а другое количество — под дробную. Например, если выделено 16 бит, можно использовать 8 бит для целой части и 8 бит для дробной. Это означает, что число будет представлено в виде:

- **Целая часть**: 8 бит
- **Дробная часть**: 8 бит

Таким образом, число будет выглядеть как:

`[Целая часть][Дробная часть]`

#### Пример представления

Для числа 12.75 в формате с фиксированной точкой с 8 битами для целой и 8 битами для дробной части:

- Целая часть (12) в двоичном виде: `00001100`
- Дробная часть (0.75) в двоичном виде: `11000000` (так как 0.75 = 0.5 + 0.25)

Объединяя эти части, получаем:

`00001100 11000000`

### Преимущества чисел с фиксированной точкой

- **Простота реализации**: Арифметические операции с числами с фиксированной точкой проще реализовать на уровне аппаратного обеспечения, так как они не требуют сложных алгоритмов для обработки дробной части.
    
- **Предсказуемость**: Поведение чисел с фиксированной точкой более предсказуемо, что делает их подходящими для приложений, где важна точность, например, в финансовых расчетах.
    
- **Меньшее потребление памяти**: В некоторых случаях числа с фиксированной точкой могут занимать меньше памяти, чем числа с плавающей точкой, особенно если диапазон значений ограничен.
    

### Недостатки чисел с фиксированной точкой

- **Ограниченный диапазон**: Числа с фиксированной точкой имеют ограниченный диапазон значений. Например, если выделено 8 бит для целой части, максимальное значение будет 255 (для беззнаковых чисел) или 127 (для знаковых).
    
- **Проблемы с переполнением**: При выполнении арифметических операций может произойти переполнение, если результат выходит за пределы представимого диапазона.
    
- **Потеря точности**: При работе с дробными числами может происходить потеря точности, особенно если дробная часть не помещается в отведенное количество битов.
    

## Представление чисел с плавающей точкой.

Числа с плавающей точкой представляются в формате, аналогичном научной нотации, где число записывается как произведение мантиссы (значащей части) и основания, возведенного в степень. Например:

$$
x = M \cdot B^E
$$

Где: $M$— мантисса (значащая часть числа), $B$ — основание (обычно 2 в компьютерах), $E$ — экспонента (показатель степени).

На ЭВМ числа с плавающей точкой обычно хранятся в двоичной системе счисления, где основание $B = 2$.

### Стандарт IEEE 754

Наиболее распространённым стандартом для представления чисел с плавающей точкой является **IEEE 754**, который был принят в 1985 году. Этот стандарт определяет формат хранения чисел, правила округления, обработки исключений и другие аспекты. В стандарте предусмотрены два основных формата:
- **Одинарная точность (32 бита)**,
- **Двойная точность (64 бита)**.

### Структура числа в формате IEEE 754
Число с плавающей точкой делится на три компонента:
1. **Знак (1 бит)**:
   - 0 — положительное число,
   - 1 — отрицательное число.
2. **Экспонента (8 бит для одинарной точности, 11 бит для двойной точности)**:
   - Хранится в формате со смещением (bias). Для одинарной точности смещение равно 127, а для двойной — 1023. Это позволяет представлять как положительные, так и отрицательные значения экспоненты.
3. **Мантисса (23 бита для одинарной точности, 52 бита для двойной точности)**:
   - Хранится в нормализованной форме, где первая значащая единица опускается (скрытая единица), так как она всегда равна 1 в нормализованных числах.

### Пример представления числа
Рассмотрим число $9.1$ в формате IEEE 754 (одинарная точность):
1. Преобразуем $9.1$ в двоичную систему: $9.1_{10} = 1001.0001100110011..._2$.
2. Записываем в нормализованной форме: $1.0010001100110011... \cdot 2^3$
3. Кодируем:
   - Знак: 0 (число положительное),
   - Экспонента: $3 + 127 = 130$ (в двоичном виде: $10000010$),
   - Мантисса: $0010001100110011...$ (23 бита).

Итоговое представление: $0 \ 10000010 \ 00100011001100110011001$.

### Преимущества
- **Широкий диапазон значений**: Числа с плавающей точкой могут представлять как очень большие, так и очень маленькие значения.
- **Гибкость**: Поддержка дробных чисел и научной нотации.
- **Стандартность**: IEEE 754 обеспечивает совместимость между различными системами.

### Ограничения
- **Погрешности округления**: Из-за конечного числа битов некоторые числа не могут быть представлены точно, что приводит к ошибкам округления.
- **Неравномерное распределение чисел**: Расстояние между соседними числами увеличивается с ростом их величины.
- **Особые значения**: Стандарт IEEE 754 вводит специальные значения, такие как:
  - **NaN (Not a Number)** — для недопустимых операций (например, деление 0 на 0),
  - **±Infinity** — для переполнения,
  - **Denormalized numbers** — для представления чисел, близких к нулю.

 # Логические операции и алгебра логики
## Основы булевой алгебры и правила построения логических функций
Булева алгебра — это раздел математики и логики, который изучает операции над логическими значениями, принимающими два состояния: истина (1) и ложь (0). Основы булевой алгебры были заложены английским математиком Джорджем Булем в XIX веке, и с тех пор она стала основой для разработки цифровых схем и логических вычислений.

### Основные операции булевой алгебры

В булевой алгебре выделяют три основные логические операции:

- **Конъюнкция (AND)**: Операция "И", обозначаемая как A∧B или A⋅B. Результат равен 1 только тогда, когда оба операнда равны 1.
    
- **Дизъюнкция (OR)**: Операция "ИЛИ", обозначаемая как A∨B или A+B. Результат равен 1, если хотя бы один из операндов равен 1.
    
- **Отрицание (NOT)**: Унарная операция, обозначаемая как ¬A или $\overline{A}$. Результат равен 1, если AAA равно 0, и наоборот.
    

### Таблицы истинности

Таблицы истинности используются для описания логических функций и показывают все возможные значения входных переменных и соответствующие результаты. Например, для операций AND и OR таблицы истинности выглядят следующим образом:

#### Таблица истинности для AND

| A   | B   | A∧B |
| --- | --- | --- |
| 0   | 0   | 0   |
| 0   | 1   | 0   |
| 1   | 0   | 0   |
| 1   | 1   | 1   |

#### Таблица истинности для OR

| A   | B   | A∨B |
| --- | --- | --- |
| 0   | 0   | 0   |
| 0   | 1   | 1   |
| 1   | 0   | 1   |
| 1   | 1   | 1   |

#### Таблица истинности для NOT

| A   | ¬A  |
| --- | --- |
| 0   | 1   |
| 1   | 0   |

### Законы булевой алгебры

Булева алгебра подчиняется ряду законов, которые помогают упрощать логические выражения:

1. **Коммутативность**:
    
    - A∧B=B∧A
    - A∨B=B∨A
2. **Ассоциативность**:
    
    - (A∧B)∧C=A∧(B∧C)
    - (A∨B)∨C=A∨(B∨C)
3. **Дистрибутивность**:
    
    - A∧(B∨C)=(A∧B)∨(A∧C)
    - A∨(B∧C)=(A∨B)∧(A∨C)
4. **Законы поглощения**:
    
    - A∨(A∧B)=A
    - A∧(A∨B)=A
5. **Законы де Моргана**:
    
    - ¬(A∧B)=¬A∨¬B
    - ¬(A∨B)=¬A∧¬B

### Построение логических функций

Логические функции могут быть представлены в виде выражений, используя булевы операции. Для построения логических функций часто используются:

- **Дизъюнктивная нормальная форма (ДНФ)**: Форма, в которой функция представляется как дизъюнкция (OR) конъюнкций (AND) переменных. Например, F=(A∧B)∨(A∧¬C).
    
- **Конъюнктивная нормальная форма (КНФ)**: Форма, в которой функция представляется как конъюнкция (AND) дизъюнкций (OR) переменных. Например, F=(A∨B)∧(¬A∨C).
## Штрих Шеффера
<img src="https://sun9-65.userapi.com/impg/UFi2SkyodVT2wHLR-xemITAH0xkb0SOrl0BiXg/XSgbAVOwtB4.jpg?size=512x384&quality=95&sign=1367b54df20a1ae5f76ebf25d5be117a&type=album" width="400" height="300" />

## Стрелка Пирса
<img src="https://sun9-27.userapi.com/impg/c4_JNMhoPLLUrMh0Jx1GxNcnHT2T7sy1iYBkeg/63jVrmAVNYY.jpg?size=960x720&quality=95&sign=c0a77dedb3c767d33799a34aae9a6402&type=album" width="400" height="300" />
## Сложение по модулю два

Сложение по модулю два обозначается символом  $⊕$ или XOR. Результат операции истинный тогда и только тогда, когда один из операндов истинный, а другой ложный. 

В естественном языке операция сложения по модулю два может быть интерпретирована как утверждение «либо A, либо B, но не оба». Это делает её аналогом конструкции «либо ... либо ...», что подчеркивает её уникальные свойства по сравнению с обычным логическим «или» (дизъюнкцией), которое возвращает истину, если хотя бы одно из утверждений истинно.
## Таблицы истинности основных логических операций
<img src="https://ucarecdn.com/63b3a369-7307-43ad-a52b-7b1df61424c1/" width="400" height="300" />
## Законы алгебры логики
### Основные законы алгебры логики

#### 1. Закон идемпотентности

- **Форма OR**: A+A=A
- **Форма AND**: A⋅A=A

Этот закон утверждает, что логическое выражение не изменится, если одно и то же значение будет использовано несколько раз.

#### 2. Закон коммутативности

- **Форма OR**: A+B=B+A
- **Форма AND**: A⋅B=B⋅A

Этот закон говорит о том, что порядок операндов не влияет на результат операции.

#### 3. Закон ассоциативности

- **Форма OR**: (A+B)+C=A+(B+C)
- **Форма AND**: (A⋅B)⋅C=A⋅(B⋅C)

Закон ассоциативности утверждает, что при выполнении операций порядок группировки не имеет значения.

#### 4. Закон дистрибутивности

- **Форма**: A⋅(B+C)=(A⋅B)+(A⋅C)

Этот закон описывает, как одна операция распределяется по другой.

#### 5. Закон поглощения

- **Форма OR**: A+(A⋅B)=A
- **Форма AND**: A⋅(A+B)=A

Закон поглощения позволяет упростить выражения, устраняя избыточные части.

#### 6. Закон двойного отрицания

- **Форма**: (A′)′=A

Этот закон утверждает, что двойное отрицание возвращает исходное значение.

#### 7. Законы о дополнении

- **Форма OR**: A+A′=1
- **Форма AND**: A⋅A′=0

Эти законы показывают, что логическое выражение и его дополнение всегда дают противоположные результаты.

#### 8. Законы Де Моргана

- **Первый закон**: (A+B)′=A′⋅B′
- **Второй закон**: (A⋅B)′=A′+B′

Законы Де Моргана описывают, как отрицание логических операций преобразуется в другие операции.
## Построение СКНФ, СДНФ
### Сумма Дизъюнктов Нормальная Форма (СДНФ)

### Построение СДНФ

1. **Создание таблицы истинности**: Начните с составления таблицы истинности для логической функции, где указываются все возможные комбинации входных переменных и соответствующие выходные значения.
    
2. **Выбор строк с выходом 1**: Найдите все строки таблицы, где выходное значение равно 1.
    
3. **Формирование дизъюнктов**: Для каждой строки, где выход 1, создайте дизъюнкт, используя переменные:
    
    - Если переменная в строке равна 1, используйте её в прямом виде.
    - Если переменная равна 0, используйте её в инверсном виде (с символом NOT).
4. **Суммирование дизъюнктов**: Объедините все полученные дизъюнкты с помощью операции OR.
    

### Пример

Для функции f(a,b,c) где выход 1 для комбинаций (0, 0, 1), (0, 1, 1) и (1, 0, 0):

- Дизъюнкты:
    - Для (0, 0, 1): a′⋅b′⋅c
    - Для (0, 1, 1): a′⋅b⋅c 
    - Для (1, 0, 0): a⋅b′⋅c′ 

СДНФ будет:  
f(a,b,c)=a′⋅b′⋅c+a′⋅b⋅c+a⋅b′⋅c′

### Произведение Конъюнктов Нормальная Форма (СКНФ)

СКНФ представляет собой логическую функцию в виде произведения (конъюнкции) сумм (дизъюнкций) переменных. Каждая сумма называется **конъюнктом** и соответствует определённой комбинации входных переменных, при которой функция принимает значение 0.

### Построение СКНФ

1. **Создание таблицы истинности**: Составьте таблицу истинности для логической функции.
    
2. **Выбор строк с выходом 0**: Найдите все строки таблицы, где выходное значение равно 0.
    
3. **Формирование конъюнктов**: Для каждой строки, где выход 0, создайте конъюнкт, используя переменные:
    - Если переменная в строке равна 0, используйте её в прямом виде.
    - Если переменная равна 1, используйте её в инверсном виде.
4. **Умножение конъюнктов**: Объедините все полученные конъюнкты с помощью операции AND.
    

### Пример

Для функции f(a,b,c), где выход 0 для комбинаций (0, 1, 0), (1, 0, 1):

- Конъюнкты:
    - Для (0, 1, 0): (a′+b+c′)(a' + b + c')(a′+b+c′)
    - Для (1, 0, 1): (a+b′+c)(a + b' + c)(a+b′+c)

СКНФ будет:  
f(a,b,c)=(a′+b+c′)(a+b′+c)
## Минимизация логических функций

Минимизация логических функций — это процесс упрощения булевых выражений и структур логических сетей с целью оптимизации цифровых схем. Этот процесс важен, поскольку он позволяет уменьшить стоимость и сложность связанных с ним схем, что в свою очередь приводит к более эффективному использованию ресурсов.

**Основные методы минимизации**

Существует несколько методов минимизации логических функций, каждый из которых имеет свои преимущества и недостатки:

- **Алгебраические методы**: Это наиболее простые методы, которые включают в себя преобразования логических функций с использованием законов алгебры логики. Они подходят для выражений средней сложности, содержащих 4-5 переменных, но могут быть подвержены человеческим ошибкам.

- **Метод карт Карно**: Этот графический метод позволяет визуально минимизировать булевы функции. Он особенно эффективен для функций с небольшим количеством переменных (до 6). Метод основан на объединении соседних клеток в карте, что позволяет исключать переменные и упрощать выражения.

- **Метод Квайна-Мак-Класки**: Этот алгоритмический метод подходит для более сложных функций и может обрабатывать большее количество переменных. Он использует таблицы для систематического исключения переменных и нахождения минимальных форм.

**Значение минимизации**

Минимизация логических функций имеет несколько ключевых преимуществ:

- **Снижение затрат**: Упрощенные логические функции требуют меньшего количества логических элементов, что снижает общие затраты на производство схем.

- **Упрощение проектирования**: Минимизация упрощает проектирование и реализацию цифровых схем, так как уменьшает количество необходимых логических операций.

- **Увеличение надежности**: Меньшее количество логических элементов также может привести к повышению надежности схем, так как уменьшается вероятность ошибок и сбоев.
## Реализация логических функций в различных базисах

Реализация логических функций в различных базисах является важным аспектом проектирования цифровых схем. Существует несколько функционально полных базисов, которые позволяют строить любые логические функции, используя определенные логические элементы. Наиболее распространенными являются базисы И-НЕ и ИЛИ-НЕ.

**Основные базисы**

- **Базис И-НЕ**: Этот базис использует логический элемент "И-НЕ" (штрих Шеффера), который позволяет реализовать функции И, ИЛИ и НЕ. Для реализации логических функций в этом базисе необходимо преобразовать исходное логическое выражение, используя закон двойного отрицания и правила де Моргана. Например, для реализации функции в базисе И-НЕ, логическое выражение сначала преобразуется в форму, где последней операцией будет отрицание, а все операции будут представлены в виде конъюнкций.

- **Базис ИЛИ-НЕ**: В этом базисе используется логический элемент "ИЛИ-НЕ". Аналогично базису И-НЕ, для реализации функций в базисе ИЛИ-НЕ также применяются правила де Моргана и двойного отрицания. Исходное выражение преобразуется так, чтобы последней операцией было отрицание, и все операции были представлены в виде дизъюнкций.

**Методы реализации**

1. **Преобразование логических функций**: Для реализации логических функций в заданном базисе необходимо сначала минимизировать функцию, используя методы, такие как карты Карно или алгоритм Квайна-Мак-Класки. После минимизации функция приводится к форме, соответствующей выбранному базису.

2. **Синтез логических схем**: После преобразования логической функции в нужный базис, можно приступить к синтезу логической схемы. Это включает в себя построение схемы, используя только те логические элементы, которые соответствуют выбранному базису. Например, для базиса И-НЕ все операции должны быть представлены в виде И-НЕ, а для базиса ИЛИ-НЕ — в виде ИЛИ-НЕ.

**Примеры реализации**

- **Пример реализации в базисе И-НЕ**: Если у нас есть логическая функция, которую нужно реализовать, мы сначала минимизируем её, а затем преобразуем в форму, где используются только операции И-НЕ. Например, функция $F = A \cdot B + C$ может быть преобразована в форму, удобную для реализации в базисе И-НЕ, используя правила де Моргана.

- **Пример реализации в базисе ИЛИ-НЕ**: Аналогично, для функции $F = A + B \cdot C$ мы можем минимизировать её и затем преобразовать в форму, где используются только операции ИЛИ-НЕ, что позволит легко синтезировать соответствующую логическую схему.

## Перевод логических схем из одного базиса в другой

Перевод логических схем из одного базиса в другой — это важный процесс в цифровой электронике, который позволяет оптимизировать схемы и использовать различные логические элементы для реализации одних и тех же функций. Существует несколько функционально полных базисов, таких как базисы И-НЕ и ИЛИ-НЕ, которые могут быть использованы для реализации любых логических функций.

**Основные принципы перевода**

1. **Функциональная полнота**: Каждый базис должен быть функционально полным, что означает, что с его помощью можно реализовать любую логическую функцию. Например, базисы И-НЕ и ИЛИ-НЕ являются функционально полными, так как с их помощью можно выразить все основные логические операции (И, ИЛИ, НЕ) и, следовательно, любые логические функции.

2. **Законы де Моргана**: При переводе логических функций между базисами часто используются законы де Моргана, которые позволяют преобразовывать логические выражения. Эти законы утверждают, что:
   - $\neg(A \land B) = \neg A \lor \neg B$
   - $\neg(A \lor B) = \neg A \land \neg B$

   Эти преобразования позволяют менять операции между И и ИЛИ, что является ключевым при переходе от одного базиса к другому.

3. **Минимизация логических функций**: Перед переводом логической схемы желательно минимизировать логическую функцию, чтобы уменьшить количество используемых элементов. Это можно сделать с помощью методов, таких как карты Карно или алгоритм Квайна-Мак-Класки, которые помогают упростить логические выражения.

**Процесс перевода**

1. **Минимизация функции**: Начните с минимизации логической функции, используя один из методов. Это позволит получить более простую и компактную форму функции, которая будет легче переводиться в другой базис.

2. **Преобразование в нужный базис**: Используя законы де Моргана и другие логические эквиваленты, преобразуйте минимизированную функцию в форму, соответствующую целевому базису. Например, если вы переводите функцию из базиса И-НЕ в базис ИЛИ-НЕ, вам нужно будет выразить все операции в терминах ИЛИ и НЕ.

3. **Синтез новой схемы**: После преобразования логической функции в нужный базис, можно приступить к синтезу новой логической схемы, используя соответствующие логические элементы. Это может включать в себя использование элементов И, ИЛИ, И-НЕ или ИЛИ-НЕ в зависимости от выбранного базиса.

**Пример перевода**

Рассмотрим пример перевода логической функции:

- Исходная функция: $F(A, B, C) = A \cdot B + \neg C$

1. **Минимизация**: Предположим, что функция уже минимизирована.
   
2. **Преобразование в базис И-НЕ**:
   Применяем закон де Моргана:  $F = \neg(\neg(A \cdot B) \cdot C)$
   Теперь функция представлена в терминах И-НЕ.

3. **Синтез схемы**: Используя элементы И-НЕ, можно построить схему, которая реализует эту функцию.

# Логические основы функционирования вычислительной техники.

## Вентили: физический и логический уровни

Вентили являются основными строительными блоками цифровых схем, и их можно рассматривать на двух уровнях: физическом и логическом. Каждый из этих уровней играет важную роль в проектировании и реализации цифровых устройств.

### Логический уровень

На логическом уровне вентили представляют собой абстракции, которые выполняют определенные логические операции над входными сигналами. Основные логические вентили включают:

- **И (AND)**: Выдает логическую единицу на выходе только тогда, когда все входы равны единице.
  
- **ИЛИ (OR)**: Выдает единицу, если хотя бы один из входов равен единице.

- **НЕ (NOT)**: Инвертирует входной сигнал, т.е. выдает единицу, если вход равен нулю, и наоборот.

- **И-НЕ (NAND)**: Выдает ноль только тогда, когда все входы равны единице. Это универсальный вентиль, так как с его помощью можно реализовать любые логические функции.

- **ИЛИ-НЕ (NOR)**: Выдает единицу только тогда, когда все входы равны нулю.

- **Исключающее ИЛИ (XOR)**: Выдает единицу, если количество единиц на входах нечетно.

Эти вентили могут быть представлены в виде таблиц истинности, которые показывают, как выходные значения зависят от входных.

### Физический уровень

На физическом уровне вентили реализуются с помощью различных технологий, включая:

- **Транзисторы**: Наиболее распространенный способ реализации логических вентилей. Транзисторы могут быть использованы для создания различных логических функций, комбинируя их в схемы. Например, вентиль И-НЕ может быть реализован с помощью двух n-канальных транзисторов, соединенных последовательно, и одного p-канального транзистора, подключенного параллельно.

- **Интегральные схемы (ИС)**: В современных устройствах логические вентили часто реализуются в виде интегральных схем, которые содержат множество вентилей на одном кристалле. Это позволяет значительно уменьшить размеры и повысить производительность цифровых устройств.

- **Полевые транзисторы (MOSFET)**: Используются в большинстве современных цифровых схем, включая CMOS-технологии, которые обеспечивают низкое потребление энергии и высокую скорость работы.

### Заключение

Вентили на логическом уровне представляют собой абстракции, которые выполняют основные логические операции, в то время как на физическом уровне они реализуются с помощью транзисторов и интегральных схем. Понимание обоих уровней важно для проектирования эффективных и надежных цифровых устройств.

## Обозначения вентилей "НЕ", "И", "ИЛИ, "исключающее ИЛИ", "НЕ И" и "НЕ ИЛИ" по ГОСТ 2.743-91, IEC 60617-12: 1997 и US ANSI 91-1984
### 1. Вентиль "НЕ" (NOT gate)

- **ГОСТ 2.743-91**: Обозначение — "0НЕ".
  
- **IEC 60617-12: 1997**: Обозначение — "0".
  
- **US ANSI 91-1984**: Обозначение — "0".

### 2. Вентиль "И" (AND gate)

- **ГОСТ 2.743-91**: Обозначение — "0И".
  
- **IEC 60617-12: 1997**: Обозначение — "0".
  
- **US ANSI 91-1984**: Обозначение — "0".

### 3. Вентиль "ИЛИ" (OR gate)

- **ГОСТ 2.743-91**: Обозначение — "0ИЛИ".
  
- **IEC 60617-12: 1997**: Обозначение — "0".
  
- **US ANSI 91-1984**: Обозначение — "0".

### 4. Исключающее ИЛИ (XOR gate)

- **ГОСТ 2.743-91**: Обозначение — "0ИсклИЛИ".
  
- **IEC 60617-12: 1997**: Обозначение — "0".
  
- **US ANSI 91-1984**: Обозначение — "0".

### 5. Вентиль "НЕ И" (NAND gate)

- **ГОСТ 2.743-91**: Обозначение — "0НЕ И".
  
- **IEC 60617-12: 1997**: Обозначение — "0".
  
- **US ANSI 91-1984**: Обозначение — "0".

### 6. Вентиль "НЕ ИЛИ" (NOR gate)

- **ГОСТ 2.743-91**: Обозначение — "0НЕ ИЛИ".
  
- **IEC 60617-12: 1997**: Обозначение — "0".
  
- **US ANSI 91-1984**: Обозначение — "0".

## Сумматоры: схемы и принцип работы

Сумматоры — это важные элементы цифровых схем, предназначенные для выполнения операций сложения. Они используются в различных устройствах, таких как процессоры, калькуляторы и другие электронные устройства. Существует несколько типов сумматоров, среди которых наиболее распространены полусумматоры и полные сумматоры.

### 1. Полусумматор (Half Adder)

**Определение**: Полусумматор — это комбинационная логическая схема, которая принимает на вход два двоичных бита и выдает два выхода: сумму и перенос (carry).

**Схема**: Полусумматор состоит из одного логического элемента XOR (исключающее ИЛИ) и одного логического элемента AND (И). 

- **Сумма (S)**: Вычисляется как $S = A \oplus B$, где $A$ и $B$ — входные биты.
- **Перенос (C)**: Вычисляется как $C = A \cdot B$.

**Таблица истинности**:

| A | B | S (Сумма) | C (Перенос) |
|---|---|-----------|-------------|
| 0 | 0 |     0     |      0      |
| 0 | 1 |     1     |      0      |
| 1 | 0 |     1     |      0      |
| 1 | 1 |     0     |      1      |

Полусумматор не может учитывать перенос из предыдущего разряда, что является его ограничением.

### 2. Полный сумматор (Full Adder)

**Определение**: Полный сумматор — это логическая схема, которая может складывать три двоичных бита: два входных бита и один бит переноса из предыдущего разряда.

**Схема**: Полный сумматор обычно состоит из двух полусумматоров и одного логического элемента OR.

- **Сумма (S)**: Вычисляется как $S = (A \oplus B) \oplus C_{in}$, где $C_{in}$ — входной перенос.
- **Перенос (C)**: Вычисляется как $C_{out} = (A \cdot B) + (C_{in} \cdot (A \oplus B))$.

**Таблица истинности**:

| A   | B   | C_{in} | C_{out} | S   |
| --- | --- | ------ | ------- | --- |
| 0   | 0   | 0      | 0       | 0   |
| 0   | 0   | 1      | 0       | 1   |
| 0   | 1   | 0      | 0       | 1   |
| 0   | 1   | 1      | 1       | 0   |
| 1   | 0   | 0      | 0       | 1   |
| 1   | 0   | 1      | 1       | 0   |
| 1   | 1   | 0      | 1       | 0   |
| 1   | 1   | 1      | 1       | 1   |

Полный сумматор может быть использован для создания более сложных схем, таких как параллельные сумматоры, которые складывают многобитные числа, используя несколько полных сумматоров в каскадной конфигурации.

### Применение сумматоров

Сумматоры находят широкое применение в различных областях:

- **Арифметико-логические устройства (АЛУ)**: Используются для выполнения арифметических операций.
- **Калькуляторы**: Основной элемент для выполнения операций сложения.
- **Процессоры**: Важная часть для выполнения операций над данными.
- **Системы обработки данных**: Используются для сложения адресов и индексов.

## Мультиплексоры

### Определение

Мультиплексор (MUX) — это комбинационное логическое устройство, которое позволяет выбирать один из нескольких входных сигналов и передавать его на один выход. Это устройство используется для управления передачей данных и сигналов в цифровых схемах.

### Принцип работы

Мультиплексор имеет несколько информационных входов и один выход, а также управляющие входы, которые определяют, какой из входных сигналов будет передан на выход. 

- **Структура**: Мультиплексор может иметь $2^n$ входов и $n$ управляющих входов. Например, 4-входной мультиплексор будет иметь 2 управляющих входа, так как $2^2 = 4$.
  
- **Выбор входа**: Сигналы на управляющих входах определяют, какой конкретный вход будет подключен к выходу. Например, если на управляющих входах поданы значения 01, то на выход будет передан сигнал с второго входа.

- **Схема**: Внутренняя структура мультиплексора может быть реализована с использованием логических элементов, таких как AND, OR и NOT. Обычно для управления мультиплексором используется дешифратор, который преобразует управляющие сигналы в соответствующие управляющие сигналы для логических элементов.

### Типы мультиплексоров

- **Цифровые мультиплексоры**: Используются для передачи цифровых сигналов, где логические уровни '0' и '1' представляют информацию.
  
- **Аналоговые мультиплексоры**: Позволяют передавать аналоговые сигналы, обеспечивая электрическое соединение между выбранным входом и выходом.

### Применение

Мультиплексоры находят широкое применение в различных областях:

- **Коммутация сигналов**: Используются для выбора одного из нескольких сигналов в системах связи.
  
- **Преобразование данных**: Могут использоваться для преобразования параллельного двоичного кода в последовательный, что позволяет экономить ресурсы при передаче данных.

- **Управление устройствами**: Применяются в триггерах, сдвигающих регистрах и других цифровых устройствах для управления потоками данных.


## Триггерные устройства

### Определение

Триггерные устройства, или триггеры, представляют собой электронные схемы, способные хранить один бит двоичной информации. Они имеют два устойчивых состояния и могут переключаться между ними под воздействием внешних сигналов. Триггеры являются основными элементами в цифровой электронике и используются для реализации памяти, счетчиков и других логических функций.

### Типы триггеров

Существует несколько основных типов триггеров, каждый из которых имеет свои особенности и области применения:

- **RS-триггер**: Это самый простой тип триггера, который имеет два входа — Reset (R) и Set (S). Он может устанавливать или сбрасывать состояние в зависимости от поданных сигналов. Однако, если оба входа активны, состояние триггера становится неопределенным.

- **JK-триггер**: Этот триггер является более универсальным и может работать как RS-триггер, но с дополнительной возможностью переключения состояния при подаче единиц на оба входа J и K. JK-триггер также требует сигнала синхронизации для изменения состояния.

- **T-триггер**: T-триггер (toggle) изменяет свое состояние на противоположное при каждом такте, когда на вход T подается единица. Он часто используется в счетчиках.

- **D-триггер**: D-триггер (delay) сохраняет значение, поданное на вход D, при активации сигнала синхронизации. Это позволяет использовать его для хранения данных и создания регистров.

### Принцип работы

Триггеры работают на основе логических элементов, таких как AND, OR и NOT. Их основная функция заключается в том, чтобы запоминать состояние, которое может быть изменено в ответ на входные сигналы. Например, в RS-триггере состояние Q устанавливается в 1, когда на вход S подается 1, и сбрасывается в 0, когда на вход R подается 1.

### Применение триггеров

Триггеры находят широкое применение в различных областях:

- **Память**: Используются в регистрах и ячейках памяти для хранения двоичных данных.

- **Счетчики**: Применяются в цифровых счетчиках для подсчета импульсов.

- **Синхронизация**: Используются для синхронизации сигналов в цифровых схемах, обеспечивая правильное время выполнения операций.

- **Логические схемы**: Входят в состав более сложных логических устройств, таких как автоматические машины и системы управления.


# Оглавление (навигация)
- [Основы информатики, определение и содержание понятия информации.](#основы-информатики-определение-и-содержание-понятия-информации)
  - [Теория информации](#теория-информации)
  - [Формула Хартли](#формула-хартли)
  - [Общая энтропия по Шеннону](#общая-энтропия-по-шеннону)
  - [Категории и свойства информации](#категории-и-свойства-информации)
  - [Формы представления информации в профессиональной деятельности](#формы-представления-информации-в-профессиональной-деятельности)
  - [Базовые информационные технологии](#базовые-информационные-технологии)
  - [Модифицированные коды](#модифицированные-коды)
- [Объем информации и системы счисления.](#объем-информации-и-системы-счисления)
  - [Представление чисел в позиционных системах счисления.](#представление-чисел-в-позиционных-системах-счисления)
  - [Перевод из любой системы счисления в десятичную и обратно.](#перевод-из-любой-системы-счисления-в-десятичную-и-обратно)
  - [Переходы между системами счисления с основаниями степени двойки](#переходы-между-системами-счисления-с-основаниями-степени-двойки)
- [Представление чисел в ЭВМ кодирование](#представление-чисел-в-эвм-кодирование)
  - [Представление положительных целых чисел.](#представление-положительных-целых-чисел)
  - [Прямой, обратный и дополнительный код для отрицательных чисел.](#прямой-обратный-и-дополнительный-код-для-отрицательных-чисел)
  - [11111011 (-5)](#11111011--5)
  - [Сложение и вычитание целых чисел.](#сложение-и-вычитание-целых-чисел)
  - [Вещественные числа и их представление](#вещественные-числа-и-их-представление)
  - [Модифицированные коды.](#модифицированные-коды-1)
  - [Представление чисел с фиксированной точкой.](#представление-чисел-с-фиксированной-точкой)
  - [Представление чисел с плавающей точкой.](#представление-чисел-с-плавающей-точкой)
- [Логические операции и алгебра логики](#логические-операции-и-алгебра-логики)
  - [Основы булевой алгебры и правила построения логических функций](#основы-булевой-алгебры-и-правила-построения-логических-функций)
  - [Штрих Шеффера](#штрих-шеффера)
  - [Стрелка Пирса](#стрелка-пирса)
  - [Сложение по модулю два](#сложение-по-модулю-два)
  - [Таблицы истинности основных логических операций](#таблицы-истинности-основных-логических-операций)
  - [Законы алгебры логики](#законы-алгебры-логики)
  - [Построение СКНФ, СДНФ](#построение-скнф-сднф)
  - [Минимизация логических функций](#минимизация-логических-функций)
  - [Реализация логических функций в различных базисах](#реализация-логических-функций-в-различных-базисах)
  - [Перевод логических схем из одного базиса в другой](#перевод-логических-схем-из-одного-базиса-в-другой)
- [Логические основы функционирования вычислительной техники.](#логические-основы-функционирования-вычислительной-техники)
  - [Вентили: физический и логический уровни](#вентили-физический-и-логический-уровни)
  - [Обозначения вентилей "НЕ", "И", "ИЛИ, "исключающее ИЛИ", "НЕ И" и "НЕ ИЛИ" по ГОСТ 2.743-91, IEC 60617-12: 1997 и US ANSI 91-1984](#обозначения-вентилей-не-и-или-исключающее-или-не-и-и-не-или-по-гост-2743-91-iec-60617-12-1997-и-us-ansi-91-1984)
  - [Сумматоры: схемы и принцип работы](#сумматоры-схемы-и-принцип-работы)
  - [Мультиплексоры](#мультиплексоры)
  - [Триггерные устройства](#триггерные-устройства)
